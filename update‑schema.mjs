/**
 * update‑schema.mjs
 *
 * This script auto‐generates src/databases/drizzle/schema.ts
 * by importing and spreading every *.model.ts from src/models/drizzle.
 */
import { promises as fs } from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const modelsDir = path.resolve(__dirname, "src", "models", "drizzle");
const schemaFile = path.resolve(__dirname, "src", "databases", "drizzle", "schema.ts");

console.log("Models directory:", modelsDir);
console.log("Schema file path:", schemaFile);

async function getModelFiles() {
	const files = await fs.readdir(modelsDir);
	return files.filter(f => f.endsWith(".model.ts"));
}

function getPascalSchemaName(modelFile) {
	const base = modelFile.replace(/\.model\.ts$/, "");
	return base.charAt(0).toUpperCase() + base.slice(1) + "Schema";
}

async function updateSchema() {
	try {
		// Ensure both paths exist
		await fs.access(modelsDir);
		await fs.access(schemaFile);

		const modelFiles = await getModelFiles();
		if (modelFiles.length === 0) {
			console.log("No model files found. Exiting.");
			return;
		}

		const existing = await fs.readFile(schemaFile, "utf8");

		// Determine which need adding (but we're regenerating fully anyway)
		const importLines = modelFiles
			.map(f => {
				const name = getPascalSchemaName(f);
				const importPath = `@/models/drizzle/${f.replace(/\.ts$/, "")}`;
				return `import * as ${name} from "${importPath}";`;
			})
			.join("\n");

		const spreadLines = modelFiles.map(f => `\t...${getPascalSchemaName(f)}`).join(",\n");

		const generated =
			`// AUTO‑GENERATED by update‑schema.mjs. Do not edit by hand.\n\n` +
			importLines +
			"\n\n" +
			`const schema = {\n${spreadLines}\n};\n\nexport default schema;\n`;

		await fs.writeFile(schemaFile, generated, "utf8");
		console.log("✅ schema.ts successfully updated with all models.");
	} catch (err) {
		console.error("❌ Failed to update schema:", err);
	}
}

updateSchema();
